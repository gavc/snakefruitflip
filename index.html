<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake Fruit Flip</title>
  <style>
    :root{
      --bg:#0f172a;            /* slate-900 */
      --panel:#111827cc;       /* slate-900 w/ alpha */
      --panel-strong:#0b1226e6;
      --accent:#34d399;        /* green-400 */
      --accent-2:#22d3ee;      /* cyan-400 */
      --danger:#f87171;        /* red-400 */
      --text:#e5e7eb;          /* gray-200 */
      --muted:#9ca3af;         /* gray-400 */
      --grid:#1f2937;          /* slate-800 */
      --good:#86efac;          /* green-300 */
      --warn:#fde68a;          /* amber-200 */
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 10% -10%, #062a23 0%, transparent 60%),
                  radial-gradient(1000px 700px at 110% 50%, #0a2640 0%, transparent 60%),
                  linear-gradient(160deg, #0b132b 0%, #111827 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    header{
      display:flex;align-items:center;justify-content:space-between;
      gap:1rem;padding:1rem clamp(1rem,3vw,2rem);
    }
    .title{
      display:flex;align-items:center;gap:.75rem;font-weight:800;letter-spacing:.3px;
    }
    .title .logo{width:40px;height:40px;display:grid;place-items:center;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));box-shadow:0 10px 25px #22d3ee33,inset 0 0 14px #0006;font-size:22px}
    .title h1{margin:0;font-size:clamp(1.05rem,1.2rem + 1vw,1.7rem)}
    .sub{font-size:.9rem;color:var(--muted)}

    .panel{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-strong) 100%);
      border:1px solid #ffffff12;border-radius:16px;box-shadow:0 10px 30px #0008, inset 0 0 0 1px #ffffff06;
      backdrop-filter: blur(6px);
    }

    .hud{ display:flex;flex-wrap:wrap;gap:.75rem;align-items:center; }
    .card{padding:.6rem .9rem;border-radius:12px}

    .score{display:flex;gap:1.25rem;align-items:center}
    .score .stat{min-width:80px;text-align:center}
    .score .label{font-size:.7rem;color:var(--muted);letter-spacing:.2px}
    .score .val{font-size:1.2rem;font-weight:700}

    .switch{display:inline-flex;align-items:center;gap:.6rem;cursor:pointer;user-select:none}
    .switch input{display:none}
    .switch .track{width:52px;height:30px;background:#0b132b;border:1px solid #ffffff18;border-radius:999px;position:relative;transition:.2s}
    .switch .thumb{position:absolute;top:3px;left:3px;width:24px;height:24px;border-radius:999px;background:linear-gradient(135deg,#e5e7eb,#9ca3af);box-shadow:0 6px 14px #0007;transition:.25s}
    .switch input:checked + .track{background:linear-gradient(135deg,var(--accent),var(--accent-2))}
    .switch input:checked + .track .thumb{left:25px;background:linear-gradient(135deg,#fff,#d1fae5)}

    .controls{display:flex;gap:.5rem;align-items:center}
    .btn{border:none;padding:.6rem .9rem;border-radius:12px;cursor:pointer;color:#0b132b;font-weight:700}
    .btn.primary{background:linear-gradient(135deg,var(--good),#5eead4)}
    .btn.secondary{background:#e5e7eb}
    .btn.danger{background:var(--danger);color:#fff}
    .btn:disabled{opacity:.6;cursor:not-allowed}

    main{display:grid;place-items:center;padding:0 clamp(.8rem,3vw,2rem)}

    .game-wrap{display:grid;grid-template-columns: 1fr; gap:1rem; width:min(92vmin,840px)}
    canvas#game{width:100%; height:auto; aspect-ratio:1/1; border-radius:18px; box-shadow:0 20px 50px #0009; background:linear-gradient(120deg,#0b132b 0%, #111827 60%); border:1px solid #ffffff10}

    .overlay{position:absolute;inset:0;display:grid;place-items:center;border-radius:18px;background:radial-gradient(300px 220px at 50% 30%,#00000066,transparent);pointer-events:none}
    .overlay h2{margin:0;font-size:clamp(1.1rem,1.2rem + 1.4vw,2rem);text-align:center}
    .overlay .hint{margin-top:.5rem;color:var(--muted);font-size:.95rem}

    .canvas-stage{position:relative}

    .badges{display:flex;flex-wrap:wrap;gap:.5rem}
    .badge{font-size:.8rem;padding:.25rem .5rem;border-radius:999px;border:1px solid #ffffff1a;background:#0b132b;}
    .badge.green{background:linear-gradient(135deg,#064e3b,#065f46);border-color:#10b98166}

    /* Speed slider */
    .speed{display:flex;align-items:center;gap:.6rem}
    .speed .label{font-size:.8rem;color:var(--muted)}
    .speed input[type=range]{width:120px}
    .speed .speedread{font-weight:700}

    footer{padding:1rem clamp(1rem,3vw,2rem);display:flex;justify-content:space-between;align-items:center;color:var(--muted)}
    footer a{color:var(--good);text-underline-offset:3px}

    .tip{color:#c7d2fe}

    @media (max-width: 520px){
      .score .stat{min-width:68px}
      .title h1{font-size:1.1rem}
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <div class="logo">üçè</div>
      <div>
        <h1>Snake Fruit Flip</h1>
        <div class="sub">A fruit‚Äëfuelled Snake with a twist.</div>
      </div>
    </div>
    <div class="hud">
      <div class="score panel card" aria-live="polite">
        <div class="stat"><div class="label">Score</div><div class="val" id="score">0</div></div>
        <div class="stat"><div class="label">Best</div><div class="val" id="best">0</div></div>
        <div class="stat"><div class="label">Length</div><div class="val" id="length">1</div></div>
      </div>
      <label class="switch panel card" title="Reverse controls after each fruit (toggleable)">
        <input type="checkbox" id="modeReverse" checked>
        <div class="track"><div class="thumb"></div></div>
        <span>Reverse‚Äëon‚Äëeat</span>
      </label>
      <div class="panel card speed" title="Adjust game speed">
        <div class="label">Speed</div>
        <input type="range" id="speed" min="0.5" max="1.5" step="0.1" value="1" aria-label="Speed (√ó)">
        <div class="speedread"><span id="speedVal">1.0√ó</span></div>
      </div>
      <div class="controls">
        <button class="btn primary" id="btnStart">Start</button>
        <button class="btn secondary" id="btnPause">Pause</button>
        <button class="btn danger" id="btnReset">Reset</button>
      </div>
    </div>
  </header>

  <main>
    <div class="game-wrap">
      <div class="badges" id="badges">
        <div class="badge">Arrows / WASD to move</div>
        <div class="badge">Space / P to pause</div>
        <div class="badge">R to reset</div>
        <div class="badge green" id="revBadge" style="display:none">Controls Reversed</div>
      </div>
      <div class="canvas-stage">
        <canvas id="game" width="576" height="576" aria-label="Snake playfield" role="img"></canvas>
        <div class="overlay" id="overlay" aria-hidden="true">
          <div>
            <h2 id="overlayTitle">Press Start or Space</h2>
            <div class="hint" id="overlayHint">Eat fruit to grow. When Reverse‚Äëon‚Äëeat is on, the controls flip after every fruit! üçìüçå</div>
          </div>
        </div>
      </div>
      <div class="panel card" id="tipPanel">
        <strong>Healthy tip:</strong> <span class="tip" id="tip">Fruits add colour and fibre to your day. üçá</span>
      </div>
    </div>
  </main>

  <footer>
    <div>Built for fun and good habits. ‚ú®</div>
    <div>Made with <span aria-hidden>üíö</span> ‚Äî <a href="#" id="aboutLink">About</a></div>
  </footer>

  <dialog id="aboutDialog" class="panel" style="border:none;border-radius:16px;padding:1rem 1.2rem;color:var(--text)">
    <h3 style="margin-top:0">Snake Fruit Flip</h3>
    <p>A simple, single‚Äëfile web game that celebrates fruit and keeps you on your toes with optional reverse controls.</p>
    <p style="font-size:.9rem;color:var(--muted)">Shortcuts: 
      <em>Arrows/WASD</em> move, <em>Space/P</em> pause, <em>R</em> reset.
    </p>
    <form method="dialog" style="text-align:right;margin-top:1rem"><button class="btn secondary">Close</button></form>
  </dialog>

  <script>
    // === Game Config ===
    const COLS = 24, ROWS = 24;      // grid
    const CELL = 24;                  // px per cell (canvas is 576x576)
    const DEFAULT_BASE_MS = 130;      // initial step interval
    const SPEEDUP_EVERY = 4;          // speed up every N fruit
    const SPEED_DELTA = 6;            // -ms each speedup

    const FRUITS = [
      {e:'üçé',name:'Apple', tip:'Crisp and rich in fibre.'},
      {e:'üçå',name:'Banana', tip:'Great source of potassium.'},
      {e:'üçá',name:'Grapes', tip:'Small bites, big antioxidants.'},
      {e:'üçì',name:'Strawberry', tip:'Vitamin‚ÄëC packed sweetness.'},
      {e:'üçç',name:'Pineapple', tip:'Tropical zing and bromelain.'},
      {e:'ü•ù',name:'Kiwi', tip:'Tangy and fibre‚Äërich.'},
      {e:'üçë',name:'Peach', tip:'Juicy with vitamins A & C.'},
      {e:'üçê',name:'Pear', tip:'Gentle on the gut, full of fibre.'},
      {e:'üçä',name:'Orange', tip:'Sunshine dose of vitamin C.'},
      {e:'üçâ',name:'Watermelon', tip:'Hydrating and refreshing.'}
    ];

    // === State ===
    let snake, dir, nextDir, food, score, best, tickMs, running = false, paused = false;
    let reversed = false; // whether keys are currently flipped
    let reverseOnEat = true; // feature toggle via UI
    let eatenCount = 0;
    let lastTime = 0, acc = 0;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const lenEl = document.getElementById('length');
    const tipEl = document.getElementById('tip');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayHint = document.getElementById('overlayHint');
    const revBadge = document.getElementById('revBadge');

    let revBadgeTimer = null;

    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');
    const modeReverse = document.getElementById('modeReverse');
    const speedInput = document.getElementById('speed');
    const speedVal = document.getElementById('speedVal');

    const aboutLink = document.getElementById('aboutLink');
    const aboutDialog = document.getElementById('aboutDialog');

    let speedMultiplier = 1;

    // High score
    best = Number(localStorage.getItem('sff_best') || localStorage.getItem('ffs_best') || 0);
    bestEl.textContent = best;

    function init(){
      snake = [ {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)} ];
      dir = {x:1,y:0};
      nextDir = {x:1,y:0};
      food = spawnFood();
      score = 0; eatenCount = 0; reversed = false; speedMultiplier = Number(speedInput.value || 1); speedVal.textContent = speedMultiplier.toFixed(1)+'√ó'; recomputeTickMs();
      updateStats();
      setTip(`Welcome! Eat fruit, grow long, avoid walls & yourself.`);
      setOverlay(true, 'Press Start or Space', reverseOnEat ? 'Reverse‚Äëon‚Äëeat is ON ‚Äî controls flip after each fruit üçç' : 'Use arrows/WASD to play.');
      setRunning(false); paused = false;
      btnPause.textContent = 'Pause';
      updateReversedBadge();
      requestAnimationFrame(loop);
    }

    function setRunning(v){ running = v; overlay.style.pointerEvents = v ? 'none' : 'auto'; }
    function setOverlay(show, title, hint){ overlay.hidden = !show; overlay.setAttribute('aria-hidden', show? 'false':'true'); if(title) overlayTitle.textContent = title; if(hint) overlayHint.textContent = hint; }
    function setTip(text){ tipEl.textContent = text; }

    function updateStats(){ scoreEl.textContent = score; lenEl.textContent = snake.length; bestEl.textContent = best; }

    function spawnFood(){
      let pos;
      do{
        pos = { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS), fruit: FRUITS[Math.floor(Math.random()*FRUITS.length)] };
      } while(snake.some(s => s.x===pos.x && s.y===pos.y));
      return pos;
    }

    function loop(ts){
      if(!lastTime) lastTime = ts;
      const dt = ts - lastTime; lastTime = ts;
      if(running && !paused){
        acc += dt;
        while(acc >= tickMs){
          tick();
          acc -= tickMs;
        }
      }
      draw();
      requestAnimationFrame(loop);
    }

    function tick(){
      // apply queued direction
      dir = nextDir;
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // collisions (walls)
      if(head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS){
        return gameOver();
      }
      // self collision
      if(snake.some((s,i) => i>0 && s.x===head.x && s.y===head.y)){
        return gameOver();
      }

      // move
      snake.unshift(head);

      // eat
      if(head.x===food.x && head.y===food.y){
        score += 1; eatenCount += 1;
        setTip(`${food.fruit.name}: ${food.fruit.tip}`);
        food = spawnFood();
        if(reverseOnEat){ reversed = !reversed; flashReversedBadge(); }
        recomputeTickMs();
        if(score > best){ best = score; localStorage.setItem('sff_best', String(best)); }
        updateStats();
      } else {
        snake.pop();
      }
    }

    function updateReversedBadge(){
      // Keep hidden unless we explicitly flash it (when a flip occurs)
      if(!reversed){
        revBadge.style.display = 'none';
        revBadge.textContent = '';
      }
    }

    function flashReversedBadge(){
      // Show 'Controls Reversed' briefly, then auto-hide
      if(revBadgeTimer){ clearTimeout(revBadgeTimer); revBadgeTimer = null; }
      if(reversed){
        revBadge.textContent = 'Controls Reversed';
        revBadge.style.display = 'inline-flex';
        revBadgeTimer = setTimeout(()=>{ revBadge.style.display = 'none'; }, 3500);
      } else {
        revBadge.style.display = 'none';
        revBadge.textContent = '';
      }
    }

    function draw(){
      // background
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // grid
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#ffffff0f';
      for(let x=0;x<=COLS;x++){
        ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,canvas.height); ctx.stroke();
      }
      for(let y=0;y<=ROWS;y++){
        ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(canvas.width,y*CELL); ctx.stroke();
      }
      ctx.restore();

      // draw snake
      for(let i=snake.length-1;i>=0;i--){
        const s = snake[i];
        const x = s.x*CELL, y = s.y*CELL;
        const hue = 150 + (i*2 % 60); // greenish gradient
        // body
        ctx.fillStyle = `hsl(${hue} 60% 45% / 1)`;
        roundRect(ctx, x+2, y+2, CELL-4, CELL-4, 6, true);
        // head eyes
        if(i===0){
          ctx.fillStyle = '#0b132b';
          const eye = 4; const off = 5;
          ctx.beginPath(); ctx.arc(x+off, y+off, 2, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(x+CELL-off, y+off, 2, 0, Math.PI*2); ctx.fill();
        }
      }

      // draw food (emoji)
      ctx.font = `${CELL-4}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(food.fruit.e, food.x*CELL + CELL/2, food.y*CELL + CELL/2 + 1);

      // overlay visibility
      overlay.hidden = running && !paused ? true : false;
      overlay.setAttribute('aria-hidden', (running && !paused) ? 'true':'false');
      if(!running){ overlayTitle.textContent = 'Press Start or Space'; }
      else if(paused){ overlayTitle.textContent = 'Paused'; }
      else { overlayTitle.textContent = ''; }
      overlayHint.textContent = paused ? 'Space or P to resume.' : (reverseOnEat ? (reversed ? 'Reversed! Up is down. Left is right.' : 'Normal controls ‚Äî until your next fruit‚Ä¶') : 'Classic controls on.');
    }

    function roundRect(ctx, x, y, w, h, r, fill){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      if(fill) ctx.fill();
    }

    // === Input ===
    const KEY_TO_DIR = {
      ArrowUp: 'up', KeyW: 'up',
      ArrowDown: 'down', KeyS: 'down',
      ArrowLeft: 'left', KeyA: 'left',
      ArrowRight: 'right', KeyD: 'right'
    };

    function translateDirection(name, reversedFlag){
      if(!reversedFlag) return name;
      switch(name){
        case 'up': return 'down';
        case 'down': return 'up';
        case 'left': return 'right';
        case 'right': return 'left';
        default: return name;
      }
    }

    function translatedDirection(name){
      return translateDirection(name, reversed);
    }

    function trySetDirection(name){
      const t = translatedDirection(name);
      const vec = dirFromName(t);
      // prevent 180¬∞ turns into self
      if(vec.x === -dir.x && vec.y === -dir.y) return;
      nextDir = vec;
      setRunning(true); // start on first move
    }

    function dirFromName(n){
      switch(n){
        case 'up': return {x:0,y:-1};
        case 'down': return {x:0,y:1};
        case 'left': return {x:-1,y:0};
        case 'right': return {x:1,y:0};
      }
      return dir;
    }

    window.addEventListener('keydown', (e)=>{
      if(KEY_TO_DIR[e.code]){ e.preventDefault(); trySetDirection(KEY_TO_DIR[e.code]); return; }
      if(e.code==='Space' || e.code==='KeyP'){ e.preventDefault(); togglePause(); }
      if(e.code==='KeyR'){ e.preventDefault(); reset(); }
    });

    // === Buttons ===
    btnStart.addEventListener('click', ()=>{ if(!running){ setRunning(true); paused=false; } });
    btnPause.addEventListener('click', togglePause);
    btnReset.addEventListener('click', reset);

    function togglePause(){ if(!running){ setRunning(true); } paused = !paused; btnPause.textContent = paused? 'Resume':'Pause'; }
    function reset(){ init(); }

    modeReverse.addEventListener('change', ()=>{
      reverseOnEat = modeReverse.checked;
      if(!reverseOnEat){
        reversed = false;
        if(revBadgeTimer){ clearTimeout(revBadgeTimer); revBadgeTimer = null; }
        updateReversedBadge();
      }
      setTip(reverseOnEat ? 'Reverse‚Äëon‚Äëeat enabled. Keep your brain sharp! üß†' : 'Classic controls enabled.');
    });

    // --- Speed helpers (now pure + tested) ---
    function computeTickMs(baseMs, speedMult, eaten, speedEvery = SPEEDUP_EVERY, delta = SPEED_DELTA){
      const bumps = Math.floor(eaten / speedEvery);
      const base = baseMs / Math.max(0.1, speedMult || 1);
      return Math.max(60, base - bumps * delta);
    }
    function recomputeTickMs(){
      tickMs = computeTickMs(DEFAULT_BASE_MS, speedMultiplier, eatenCount);
    }

    // Speed control
    speedInput.addEventListener('input', ()=>{
      speedMultiplier = Number(speedInput.value);
      speedVal.textContent = speedMultiplier.toFixed(1)+'√ó';
      recomputeTickMs();
      setTip(speedMultiplier>1 ? 'Faster speed set.' : (speedMultiplier<1 ? 'Slower pace set.' : 'Speed reset to normal.'));
    });

    aboutLink.addEventListener('click',(e)=>{ e.preventDefault(); aboutDialog.showModal(); });

    function gameOver(){
      setRunning(false); paused=false;
      setOverlay(true, 'Game Over', `Score ${score}. ${reverseOnEat ? 'Reverse‚Äëon‚Äëeat was ' + (reversed? 'ON (at finish)':'ON') : 'Classic controls.'} Press R to reset.`);
    }

    // --- Lightweight self-tests (open DevTools console to see results) ---
    (function selfTests(){
      try {
        console.groupCollapsed('Snake Fruit Flip: self-tests');
        // translateDirection tests
        console.assert(translateDirection('up', false) === 'up', 'translateDirection: up unchanged when not reversed');
        console.assert(translateDirection('down', true) === 'up', 'translateDirection: down -> up when reversed');
        console.assert(translateDirection('left', true) === 'right', 'translateDirection: left -> right when reversed');

        // dirFromName tests
        const u = dirFromName('up');  console.assert(u.x===0 && u.y===-1, 'dirFromName up');
        const r = dirFromName('right'); console.assert(r.x===1 && r.y===0, 'dirFromName right');

        // computeTickMs tests
        const base=130;
        const t0 = computeTickMs(base, 1, 0); // 130
        const t1 = computeTickMs(base, 1, 4); // 124 (one bump)
        console.assert(Math.abs(t0-130)<1e-9, 'computeTickMs baseline');
        console.assert(Math.abs(t1-124)<1e-9, 'computeTickMs one bump');
        const t2 = computeTickMs(base, 1, 8); // 118 (two bumps)
        console.assert(Math.abs(t2-118)<1e-9, 'computeTickMs two bumps');
        console.assert(computeTickMs(base, 0.2, 100) >= 60, 'computeTickMs clamps to >=60ms');
        const fast = computeTickMs(base, 1.5, 0);
        console.assert(fast < t0, 'faster when speed>1');
        const slow = computeTickMs(base, 0.5, 0);
        console.assert(slow > t0, 'slower when speed<1');
        console.groupEnd();
      } catch(e){
        console.warn('Self-tests encountered an error:', e);
      }
    })();

    // boot
    init();
  </script>
</body>
</html>
